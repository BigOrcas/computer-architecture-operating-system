# ch10. 프로세스와 스레드
## 10-1. 프로세스 개요
### 프로세스 직접 확인하기
컴퓨터가 부팅되는순간 수많은 프로세스들이 실행됨.

확인 명령
```
> ps -ef
```
- 우리가 실행한 프로세스 외에도 알 수 없는 여러 프로세스가 실행되고 있는 것을 확인할 수 있음
- 포그라운드 프로세스(forgeground process) : 사용자가 보는 앞에서 실행되는 프로세스
- 백그라운드 프로세스(background process) : 사용자가 보지 못하는 뒤편에서 실행되는 프로세스
- 데몬(daemon) : 사용자와 상호작용하지 않고 정해진 일만 수행하는 백그라운드 프로세스
    - 유닉스 운영체제에서는 데몬, 윈도우 운영체제에서는 서비스(service)라고 함

### 프로세스 제어 블록(PCB)
- 프로세스가 돌아가며 한정된 시간 만큼만 CPU를 이용하고, 사용 종료 시 시간이 끝났다는 인터럽트(타이머 인터럽트)발생시켜 양보
- 운영체제는 빠르게 번갈아 수행되는 프로세스의 실행 순서를 관리하고, 프로세스에 CPU를 비롯한 자원을 배분함 -> 이를 운영하기 위해 PCB 이용
- 프로세스를 식별하기 위한 정보들이 저장됨
- PCB는 커널영역에 생성됨
- PCB는 프로세스 생성 시에 만들어지고 실행이 끝나면 폐기됨

PCB에 담기는 정보
- 프로세스 ID(PID)
    - 프로세스 식별 id
- 레지스터 값
    - 해당 프로세스가 실행하며 사용했던 레지스터값이 담김(프로세스가 자신의 차례가 돌아오면 이전까지 사용했던 레지스터값 복원해야 하기 때문)
- 프로세스 상태
    - 현재 프로세스가 어떤 상태인지 정보
- CPU 스케줄링 정보
    - 프로세스가 언제, 어떤 순서로 CPU 할당받을지 정보
- 메모리 관리 정보
    - 프로세스마다 메모리에 저장된 위치가 다름. 레지스터 정보와 페이지 테이블 정보가 담김
- 사용한 파일과 입출력장치 목록
    - 프로세스 실행 과정 중 IO나 파일 사용하면 PCB에 해당 내용이 명시됨

### 문맥 교환
- 문맥(context) :  하나의 프로스ㅔ스 수행을 재개하기 위해 기억해야 할 정보. 해당 프로세의 PCB에 표현되어 있음.
- 문맥 교환(context switching) : 기존 프로세스의 문맥을 PCB에 백업하고 새로운 프로세스를 실행하기 위해 문맥을 PCB로부터 복구하여 새로운 프로세스를 실행하는 것

### 프로세스의 메모리 영역
- 코드 영역(code segment)
    - = text segment
    - 실행할 수 있는 코드. 기계어로 이루어진 명령어가 전용됨
    - 쓰기 금지(읽기전용)
    - 정적 할당 영역(크기가 바뀌지 않음)
- 데이터 영역(data segment)
    - 프로그램이 실행하는동안 유지할 데이터가 저장되는 공간
    - 전역변수가 저장되는 공간
    - 정적 할당 영역(크기가 바뀌지 않음)
- 힙 영역(heap segment)
    - 프로그래머가 직접 할당할 수 있는 저장공간
    - 프로그래밍 과정에서 힙 영역 할당했으면 언젠가는 해당 영역 반납해야 함
    - 반환하지 않으면 메모리 낭비 초래함(메모리 누수 memory leack 현상)
    - 동적 할당 영역
- 스택 영역(stack segment)
    - 데이터를 일시적으로 저장하는 공간
    - 동적 할당 영역


## 10-2. 프로세스 상태와 계층 구조
### 프로세스 상태
- 생성 상태(new)
    - 이제 막 메모리에 적재되어 PCB 할당받은상태
- 준비 상태(ready)
    - 당장 CPU 받아 실행 가능하지만, 차례가 아니라 기다리는 상태
    - 디스패치 : 준비중인 상태 프로세스가 실행상태로 전환되는 것
- 실행 상태(running)
    - CPU를 할당받아 실행중인 상태.
    - 할당된 시간을 모두 사용하면(타이머 인터럽트 발생) 다시 준비상태가 됨.
    - 입출력장치를 사용해서 입출력장치 작업 끝날 때 까지 기다려야 하면 대기상태가 됨
- 대기 상태(bloked)
    - 입출력 작업 기다리는 상태
    - 입출력 작업 완료되면 준비 상태가 됨
- 종료 상태(terminate)
    - 프로세스가 종료된 상태
    - 운영체제는 PCB와 프로세스가 사용한 메모리를 정리함

### 프로세스 계층 구조
- 부모 프로세스 : 생성한 새로운 프로세스
- 자식 프로세스 : 부모 프로세스에 의해 생성된 프로세스
    - 부모 프로세스와 다른 프로세스를 가짐
    - 자식 프로세스의 PCB의 부모프로세스의 PID인 PPID(Parent PID)가 기록되기도 함

### 프로세스 생성 기법
- 부모 프로세스를 통해 생성된 자식 프로세스는, 복제와 옷 갈아입기를 통해 실행됨
    - 부모 프로세스는 fork를 통해 복사본을 자식 프로세스로 생성
    - 만들어진 복사본(자식 프로세스)은 exec를 통해 자신의 메모리 공간을 다른 프로그램으로 교체
    - fork와 exec는 시스템 호출임.

C, C++, Python, Java 로 프로세스 다루는 예제
- https://github.com/kangtegong/self-learning-cs

## 10-3. 스레드
- thread : 실행의 단위
    - 프로세스를 구성하는 실행의 흐름 단위

### 프로세스와 스레드
- 전통적인 프로세스는 한 번에 하나의 일만 처리 가능했음 => 단일 스레드 프로세스
- 스레드 개념이 도입되며 하나의 프로세스가 한 번에 여러 일을 동시에 처리 할 수 있게 됨
- 프로세스 : 실행되는 프로그램
- 스레드 : 프로세스를 구성하는 실행 흐름 단위
- 많은 운영체제가 CPU에 처리 작업을 전달할 때 프로세스가 아닌 스레드 단위로 전달함. 스레드는 프로세스 자원을 공유한 채 실행에 필요한 최소한의 정보로 실행됨

### 멀티 프로세스와 멀티 스레드
- 멀티 프로세스 : 여러 프로세스를 동시에 실행하는 것
- 멀티 스레드 : 여러 스레드로 프로세스를 동시에 실행하는 것

멀티 프로세스와 멀티 스레드의 차이
- 프로세스 : 자원 공유 X -> 자원 독립적으로 사용 가능. 하나의 프로세스에 문제가 생겨도 다른 프로세스에 지장이 적거나 없음
- 스레드 : 자원 공유 O -> 협력과 통신에 유리.

# 내 생각
- 확실히 운영체제로 넘어가니까 중요한 단원이 많이 나온다 느꼈습니다.

# 논의할 내용
- 서버가 실행될 때의 프로세스 계층 구조는 어떻게 구성되어 있을까요?
