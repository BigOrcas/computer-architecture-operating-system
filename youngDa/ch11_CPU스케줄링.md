# ch11. CPU 스케줄링
## 11-1. CPU 스케줄링 개요
CPU 스케줄링 : 운영체제가 각 프로세스에 CPU 자원을 분배하는 것
### 프로세스 우선순위
- 프로세스마다 우선순위가 다르기 때문에, 반드시 요청 순대로 CPU를 사용할 수 있다는 보장이 없음
- 입출력 집중 프로세스(I/O bound process) : 비디오 재생, 디스크 백업 작업 등 입출력 작업이 많은 프로세스
    - 입출력 대기 상태에 더 많이 머물게 됨
- CPU 집중 프로세스(CPU bound process) : 복잡한 수학연산, 컴파일, 그래픽 처리 등 CPU 작업이 많은 프로세스
    - 실행 상태에 더 많이 머물게 됨
- CPU burst : CPU를 이용하는 작업
- I/O burst : 입출력장치를 기다리는 작업

=> CPU 집중 프로세스와 입출력 집중 프로세스가 동시에 CPU 작업을 요청한 경우, 입출력 집중 프로세스에 먼저 CPU를 주는 것이 효율적
- 입출력 집중 프로세스는 CPU를 잠시 사용하고 바로 입출력 대기상태에 들어가지만, CPU 집중 프로세스는 계속해서 CPU 를 사용하기 때문
- 따라서 프로세스마다 **우선순위** 를 부여하여 프로세스를 관리함.
- 우선순위가 높은 프로세스는 더 빨리, 더 자주 실행됨

### 스케줄링 큐
- 스케줄링 큐(scheduling queue) : CPU를 사용하고 싶은 프로세스들, 메모리에 적재되고 싶은 프로세스들, 입출력장치를 사용하고 싶은 프로세스들은 줄 세워서 관리하는 큐.
- 준비 큐(ready queue) : CPU를 이용하고 싶은 프로세스들이 서는 줄
- 대기 큐(waiting queue) : 입출력장치를 이용하기 위해 대기 상태에 접어든 프로세스들이 서는 줄

### 선점형과 비선점형 스케줄링
- 선점형 스케줄링(preemptive scheduling) : 프로세스가 CPU를 비롯한 자원을 사용하고 있어도, OS가 강제로 뺏어 다른 프로세스에 할당하는 스케줄링 방식
    - 더 급한 프로세스가 끼어들어, 특정 프로세스 자원 독점 막고 고르게 자원 분배 가능
    - 문맥 교환에서의 오버헤드 발생
- 비선점형 스케줄링(non-preempive scheduling) : 하나의 프로세스가 자원을 사용하고 있으면 그 프로세스가 종료되거나 대기상태에 들어가기 전 까지 다른 프로세스가 끼어들 수 없는 스케줄링
    - 문맥 교환 오버헤드 적음
    - 자원 독점중에 기다리는 방법밖에 없음


## 11-2. CPU 스케줄링 알고리즘
### 스케줄링 알고리즘의 종류
#### 선입 선처리 스케줄링 (FCFS 스케줄링. First Come First Served Scheduling)
- 준비큐에 삽입된 순서대로 프로세스 처리하는 비선점형 스케줄링 방식
- 때때로 프로세스들이 기다리는 시간이 매우 길어질 수 있는 부작용
    - 호위효과(convoy effect) : A, B, C 프로세스가 순서대로 준비큐에 들어왔고, 각각 CPU를 20ms, 5ms, 2ms를 사용한다 가정하면, C프로세스는 2ms 실행을 위해 25ms를 대기하여 CPU 실행에 총 27ms가 걸리는 현상...

#### 최단 작업 우선 스케줄링(SJF 스케줄링. Shortest Job First Scheduling)
- 호위효과를 방지하기 위해 CPU 이용 시간의 길이가 가장 짧은 프로세스부터 실행하는 방식
- 비선점형 스케줄링 알고리즘

#### 라운드 로빈 스케줄링(Round robin scheduling)
- 선입 선처리 스케줄링에 타입 슬라이스 개념이 더해진 스케줄링
    - 타임 슬라이스 : 각 프로세스가 CPU를 사용할 수 있는 정해진 시간.
- 정해진 타임 슬라이스만큼 시간을 돌아가며 CPU를 이용하는 **선점형** 스케줄링.
    - 삽입된 순서로 CPU를 이용하되, 정해진 시간만큼만 이용하고 문맥교환
    - 타임 슬라이스가 지나치게 크면 호위효과 발생, 너무 작으면 문맥교환에 더 많은 시간 발생

#### 최소 잔여 시간 우선 스케줄링(SRT 스케줄링. Shortest Remaining Time)
- 최단 작업 우선 스케줄링 + 라운드 로빈 스케줄링
- 프로세스를 정해진 타임 슬라이스만큼 CPU를 사용하되, 남은 작업 시간이 가장 적은 프로세스가 선택됨

#### 우선순위 스케줄링(Priority Scheduling)
- 프로세스에 우선순위를 부여하고, 가장 높은 우선순위를 가진 프로세스부터 실행하는 알고리즘
- 우선순위가 낮은 프로세스는 먼저 삽입되어도, 높은 우선순위 프로세스로 인해 계속해서 연기될 수 있음
    - 기아(starvation) 현상 : 우선순위 높은 프로세스로 인해 낮은 프로세스가 밀리는 현상
    - 에이징(agining) : 기아 현상을 막기 위해, 오래 대기한 프로세스 우선순위를 점차 높이는 방식

#### 다단계 큐 스케줄링(multilevel queue scheduling)
- 우선순위 스케줄링의 발전된 형태
- 우선순위별로 준비 큐를 여러 개 사용하는 스케줄링 방식.
- 우선순위가 가장 높은 큐에 있는 프로세스를 우선 처리하고, 높은 우선순위의 큐가 비어있으면 그 다음 큐에 있는 프로세스를 처리하는 방식
- 큐별로 타입 슬라이스를 여러 개 지정 할 수도 있고, 큐마다 다른 스케줄링 알고리즘을 사용 할 수도 있음
- 다만 프로세스들은 큐 사이를 이동할 수 없음 => **기아 현상 발생 가능**

#### 다단계 피드백 큐 스케줄링(mulilevel feedback queue scheduling)
- 다단계 큐 스케줄링의 발전된 형태
- 프로세스들이 큐 사이를 이동할 수 있음.
- 새로 준비된 프로세스가 있다면 우선 우선순위가 가장 높은 우선순위 큐에 삽입되고, 일정 시간(타임 슬라이스)동안 실행됨
- 프로세스가 해당 큐에서 실행이 끝나지 않으면, 다음 우선순위 큐에 삽입되어 실행됨. -> 실행 끝나지 않으면 또 다음... 점점 우선순위가 낮아짐
    - 즉, CPU를 오래 사용해야 하는 CPU 집중 프로세스들은 점차 우선순위가 낮아지고, CPU 적게 사용하는 입출력 집중 프로세스가 우선순위 높은 큐에서 실행되게 됨.
- 낮은 우선순위 큐에서 너무 오래 기다리고 있는 프로세스가 있다면 점차 우선순위가 높은 큐로 이동시키는 에이징 기법을 적용시켜 기아 현상 예방함
- 가장 일반적인 CPU 알고리즘

# 내 생각
- 실제로 CPU가 작업을 처리하는 여러 알고리즘을 배울 수 있었습니다. 자료구조에서 배운 큐가 이렇게 활발하게 사용되니 신기했습니다.

# 논의할 내용
- 백엔드 단에서 프로세스 우선순위를 임의로 조작할 수 있을까요?
